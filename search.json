[{"title":"redis实现排行榜","date":"2020-10-08T23:59:47.215Z","url":"/2020/10/09/redis_02/","tags":[["redis","/tags/redis/"]],"categories":[["redis","/categories/redis/"]],"content":"redis排行榜为什么使用Redis实现排行榜？​1. Redis作为一款缓存数据库，性能优异，使用Redis可以提升服务存取数据的性能。​2. Redis的zset（有序集合）数据结构，天然具备作为排行榜的优势。 怎么使用Redis实现排行榜？​1. 使用Redis的zset数据结构，其中key为固定值，value为排行榜名称（唯一id），score为排行分数（排序点击数）。2. 我们记录点击数，每点击一次，点击次数越多在排行榜中所在的排名越高。​3. Redis的zset数据结构，使用的是从大到小的排序方式，所以我们使用负数来作为排名分数，每点击一次，排行榜的分数+1。 zincrby | zrevrange | in_bulkdemo 效果"},{"title":"Django orm创表字段类型","date":"2020-10-06T01:06:26.212Z","url":"/2020/10/06/django%20orm%20%E5%88%9B%E8%A1%A8%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"Django通过model层不可以创建数据库，但可以创建数据库表，以下是创建表的字段以及表字段的参数。一、字段1、models.AutoField 自增列= int(11) 如果没有的话，默认会生成一个名称为 id 的列，如果要显示的自定义一个自增列，必须将给列设置为主键 primary_key=True。2、models.CharField 字符串字段 必须 max_length 参数3、models.BooleanField 布尔类型=tinyint(1) 不能为空，Blank=True4、models.ComaSeparatedIntegerField 用逗号分割的数字=varchar 继承CharField，所以必须 max_lenght 参数5、models.DateField 日期类型 date 对于参数，auto_now =True则每次更新都会更新这个时间；auto_now_add 则只是第一次创建添加，之后的更新不再改变。6、models.DateTimeField 日期类型 datetime 同DateField的参数7、models.Decimal 十进制小数类型= decimal 必须指定整数位max_digits和小数位decimal_places8、models.EmailField 字符串类型（正则表达式邮箱）=varchar 对字符串进行正则表达式9、models.FloatField 浮点类型= double10、models.IntegerField 整形11、models.BigIntegerField 长整形 integer_field_ranges ={ ‘SmallIntegerField’?-32768,32767), ‘IntegerField’?-2147483648,2147483647), ‘BigIntegerField’?-9223372036854775808,9223372036854775807), ‘PositiveSmallIntegerField’:(0,32767), ‘PositiveIntegerField’:(0,2147483647), }12、models.IPAddressField 字符串类型（ip4正则表达式）13、models.GenericIPAddressField 字符串类型（ip4和ip6是可选的） 参数protocol可以是：both、ipv4、ipv6 验证时，会根据设置报错14、models.NullBooleanField 允许为空的布尔类型15、models.PositiveIntegerFiel 正Integer16、models.PositiveSmallIntegerField 正smallInteger17、models.SlugField 减号、下划线、字母、数字18、models.SmallIntegerField 数字 数据库中的字段有：tinyint、smallint、int、bigint19、models.TextField 字符串=longtext20、models.TimeField 时间 HH:MM[:ss[.uuuuuu]]21、models.URLField 字符串，地址正则表达式22、models.BinaryField 二进制23、models.ImageField图片24、models.FilePathField文件二、字段参数1、null=True 数据库中字段是否可以为空2、blank=True django的 Admin 中添加数据时是否可允许空值3、primary_key = False 主键，对AutoField设置主键后，就会代替原来的自增 id 列4、auto_now 和 auto_now_add auto_now 自动创建—无论添加或修改，都是当前操作的时间 auto_now_add 自动创建—永远是创建时的时间5、choicesGENDER_CHOICE = ((u’M’, u’Male’),(u’F’, u’Female’),)gender = models.CharField(max_length=2,choices = GENDER_CHOICE)6、max_length7、default 默认值8、verbose_name Admin中字段的显示名称9、name|db_column 数据库中的字段名称10、unique=True 不允许重复11、db_index = True 数据库索引12、editable=True 在Admin里是否可编辑13、error_messages=None 错误提示14、auto_created=False 自动创建15、help_text 在Admin中提示帮助信息16、validators=[]17、upload-to 在Python代码中创建数据表的过程如下，创建表的过程和MySQL利用SQL语句建表不一样。在Django中通过在model层 创建类的方法，通过命令行 Python manage.py migrate, 创建表，然后利用命令 Python manage.py makemigrations 应用表。"},{"title":"Django配置xadmin后台管理","date":"2020-10-05T00:35:21.279Z","url":"/2020/10/05/django%E9%85%8D%E7%BD%AExadmin%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"注意：Django2.1 和 mysql 5.5 有冲突， 需要把MySQL升级5.7 根据此博客升级mysql :  一、用pycharm创建一个my_xadmin项目二、安装必须的依赖组件1、打开pycharm终端安装1.x版本django 2.安装xadmin 三、配置运行xadmin 需要再项目根目录下创建static,collect_static两个目录 2、配置xadmin路由，修改urls.py 3、创建数据库并创建超级用户 4、拉取静态文件到本地 5、运行并访问后台 四、添加一个App，实现model的curd功能1、添加一个IDC机房管理app，并在settings.py中加入IdcManager 2、添加一个model 3、打开IdcManager的init.py文件添加： 4、修改apps.py文件 5、修改admin.py 6、创建表并启动测试 五、外键关联以及用户关联1、model添加一个server，关联用户以及idc机房 2、admin.py 添加注入模板,注意save_models这里通过修改原先的方法来实现自定义修改字段 3、启动并测试 4、根据登录用户过滤显示选项 这样修改完后重启项目，就可以看到根据登录的用户，看到的选项不一样"},{"title":"django 对接elasticsearch实现全文检索","date":"2020-10-02T09:10:17.914Z","url":"/2020/10/02/%E4%BD%BF%E7%94%A8es%20%E5%AE%9E%E7%8E%B0%E6%A3%80%E7%B4%A2%E5%8A%9F%E8%83%BD/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"第一步：安装elasticsearch环境（docker 安装）拉取镜像 运行容器 第二步:首先安装相关的依赖包 第三步：在django项目配置文件settings.py 中注册应用 haystack: django的一个包，可以方便地对model里面的内容进行索引、搜索。设计为支持whoosh，soir，Xapian，Elasticsearc四种全文检索引擎后端，属于一种全文检索的框架 whoosh: 纯Python编写的全文搜索引擎，虽然性能比不上sphix、xapian、Elasticsearc等，但是无二进制包，程序不会莫名其妙的奔溃，对于小型的站点，whoosh已经足够使用 jieba：一款免费的中文分词包 第四步：在django项目配置文件settings.py 中指定搜索的后端 第五步：创建索引类在此之前要先创建model类，并插入数据 在需要进行索引的应用的目录下创建文件search_indexes.py, 在该文件内创建该索引类 我在myapp应用下创建:search_indexes.py 第六步：在templates目录中创建text字段使用的模板文件创建文件templates/search/indexes/myapp/book_text.txt文件中定义 第七步：手动更新索引 第八步：创建haystack序列化器 第九步：创建视图类 第十步：添加路由 第十一步：测试"},{"title":"Celery 异步发送基于阿里云的短信","date":"2020-09-30T02:59:56.644Z","url":"/2020/09/30/celery%20%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%20%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"步骤1： 在阿里云 “短信服务” 中创建一个签名 步骤2： 在阿里云 “短信服务” 中创建一个短信模块 office_demo下：配置: settings.py 中添加 url.py 中添加 celery_sms.py中 view.py 中 记录返回的数据转换方式： "},{"title":"vue 发送短信60秒倒计时","date":"2020-09-30T01:59:18.920Z","url":"/2020/09/30/vue%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A160%E7%A7%92%E5%80%92%E8%AE%A1%E6%97%B6/","tags":[["vue","/tags/vue/"]],"categories":[["vue","/categories/vue/"]],"content":"代码: "},{"title":"MySQL基本操作","date":"2020-09-29T11:33:48.694Z","url":"/2020/09/29/MySQL%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","tags":[["mysql","/tags/mysql/"]],"categories":[["mysql","/categories/mysql/"]],"content":"前言Django框架功能齐全自带数据库操作功能，本文主要介绍Django的ORM框架 到目前为止，当我们的程序涉及到数据库相关操作时，我们一般都会这么搞： 创建数据库，设计表结构和字段 使用 MySQLdb 来连接数据库，并编写数据访问层代码 业务逻辑层去调用数据访问层执行数据库操作 ORM是什么？：(在django中，根据代码中的类自动生成数据库的表也叫–code first) ORM：Object Relational Mapping(关系对象映射) 类名对应——》数据库中的表名 类属性对应———》数据库里的字段 类实例对应———》数据库表里的一行数据 obj.id obj.name…..类实例对象的属性 Django orm的优势： Django的orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句；所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite….，如果数据库迁移，只需要更换Django的数据库引擎即可； 一、Django连接MySQL1、创建数据库 （注意设置 数据的字符编码） 由于Django自带的orm是data_first类型的ORM，使用前必须先创建数据库 2、修改project中的settings.py文件中设置 连接 MySQL数据库（Django默认使用的是sqllite数据库） 扩展：查看orm操作执行的原生SQL语句 在project中的settings.py文件增加 3、修改project 中的__init__py 文件设置 Django默认连接MySQL的方式 4、setings文件注册APP 5、models.py创建表 6、进行数据迁移 6.1、在winds cmd或者Linux shell的项目的manage.py目录下执行 扩展：修改表结构之后常见报错 这个报错：因为表创建之时，新增字段既没有设置默认值，也没有设置新增字段可为空，去对应原有数据导致； 2中解决方法： 1.设置新增字段可以为空 2.设置新增字段默认值为 当前时间 3.更多问题 python manage.py makemigrations :把你写在models中的代码翻译成增、删、改的 SQL 语句； python manage.py migrate；讲python manage.py makemigrations翻译的SQL语句去数据库执行； python manage.py migrate –fake；假设 migrate 把所有SQL语句执行成功了； 我在使用Django构建表结构的时候很长一段时间都是没有了解以上3条语句的执行意义，所有经常在修改表结构之后出现报错； 出现报错的原因： 无非就是 makemigrations翻译的 SQL，跟数据库里面真实的表结构 相互冲突,增加、删除不了表、外键关系； 所以遇到报错 你应该先把model中的代码注释掉—–》python manage.py migrate –fake——》python manage.py makemigrations 去数据库把已经存在的表、外键删掉（确保数据库目前的状态，可以让makemigrations翻译出来的SQL语句在数据库里执行成功；然后migrate）——–》 python manage.py migrate； 7.设置pycharm可视化MySQL 二、modles.py创建表ORM字段介绍Djan提供了很多字段类型，比如URL/Email/IP/ 但是mysql数据没有这些类型，这类型存储到数据库上本质是字符串数据类型,其主要目的是为了封装底层SQL语句； 1、字符串类（以下都是在数据库中本质都是字符串数据类型，此类字段只是在Django自带的admin中生效） 扩展 models.CharField 对应的是MySQL的varchar数据类型 char 和 varchar的区别 : char和varchar的共同点是存储数据的长度，不能 超过max_length限制， 不同点是varchar根据数据实际长度存储，char按指定max_length（）存储数据；所有前者更节省硬盘空间； 2、时间字段 models.DateTimeField(null=True) date=models.DateField() 3、数字字段 (max_digits=30,decimal_places=10)总长度30小数位 10位） 4、枚举字段 扩展 在数据库存储枚举类型，比外键有什么优势？ 1、无需连表查询性能低，省硬盘空间(选项不固定时用外键)2、在modle文件里不能动态增加（选项一成不变用Django的choice） 其他字段 字段参数介绍1.数据库级别生效 View Code 2、Django admin级别生效 View Code 三、ORM单表操作0、orm操作前戏orm使用方式： orm操作可以使用类实例化，obj.save的方式，也可以使用create（）的形式 QuerySet数据类型介绍 QuerySet与惰性机制 所谓惰性机制：Publisher.objects.all()或者.filter()等都只是返回了一个QuerySet（查询结果集对象），它并不会马上执行sql，而是当调用QuerySet的时候才执行。 QuerySet特点： View Code 增加和查询操作 增 View Code 根据条件判断，增加？更新？ View Code 删 View Code 改 View Code 查 View Code 连表查询 View Code 1、基本操作 View Code 2、进阶操作（了不起的双下划线）利用双下划线将字段和对应的操作连接起来 View Code 3、其他操作（执行原生SQL） 四、ORM连表操作我们在学习django中的orm的时候，我们可以把一对多，多对多，分为正向和反向查找两种方式。 正向查找：ForeignKey在 UserInfo表中，如果从UserInfo表开始向其他的表进行查询，这个就是正向操作，反之如果从UserType表去查询其他的表这个就是反向操作。 一对多：models.ForeignKey(其他表) 多对多：models.ManyToManyField(其他表) 一对一：models.OneToOneField(其他表) 正向连表操作总结： 所谓正、反向连表操作的认定无非是Foreign_Key字段在哪张表决定的， Foreign_Key字段在哪张表就可以哪张表使用Foreign_Key字段连表，反之没有Foreign_Key字段就使用与其关联的 小写表名； 1对多：对象.外键.关联表字段，values(外键字段__关联表字段) 多对多：外键字段.all() 反向连表操作总结： 通过value、value_list、fifter 方式反向跨表：小写表名__关联表字段 通过对象的形式反向跨表：小写表面_set().all() 前端ajax需要携带的参数 根据前端参数，返回不同数据库结果 应用场景： 一对多：当一张表中创建一行数据时，有一个单选的下拉框（可以被重复选择） 例如：创建用户信息时候，需要选择一个用户类型【普通用户】【金牌用户】【铂金用户】等。 多对多：在某表中创建一行数据是，有一个可以多选的下拉框 例如：创建用户信息，需要为用户指定多个爱好 一对一：在某表中创建一行数据时，有一个单选的下拉框（下拉框中的内容被用过一次就消失了 例如：原有含10列数据的一张表保存相关信息，经过一段时间之后，10列无法满足需求，需要为原来的表再添加5列数据 1、1对多如果A表的1条记录对应B表中N条记录成立，两表之间就是1对多关系；在1对多关系中 A表就是主表，B表为子表，ForeignKey字段就建在子表； 如果B表的1条记录也对应A表中N条记录，两表之间就是双向1对多关系，也称为多对多关系； 在orm中设置如果 A表设置了外键字段user=models.ForeignKey(‘UserType’)到B表(注意外键表名加引号) 就意味着 写在写A表的B表主键， （一列），代表B表的多个（一行）称为1对多， 查询 总结：利用orm获取 数据库表中多个数据 获取到的数据类型本质上都是 queryset类型，类似于列表，内部有3种表现形式（对象，字典，列表） modle.表名.objects.all()modle.表名.objects.values()modle.表名.objects.values() 跨表 正操作 所以表间只要有外键关系就可以一直点下去。。。点到天荒地老 所以可以通过obj.外键.B表的列表跨表操作（注意！！orm连表操作必须选拿单个对象，不像SQL中直接表和表join就可以了） print(obj.cls.title) foreignkey字段在那个表里，那个表里一个”空格”代表那个表的多个（一行） \\1. 在取得时候跨表q = UserInfo.objects.all().first()q.ug.title\\2. 在查的时候就跨表了UserInfo.objects.values(‘nid’,’ug_id’)UserInfo.objects.values(‘nid’,’ug_id’,’ug__title’) #注意正向连表是 外键__外键列 反向是小写的表名\\3. UserInfo.objects.values_list(‘nid’,’ug_id’,’ug__title’) 反向连表： 反向操作无非2种方式： 1、通过对象的形式反向跨表：小写表面_set().all() 2、通过value和value_list方式反向跨表：小写表名__字段 \\1. 小写的表名_set 得到有外键关系的对象 obj = UserGroup.objects.all().first()result = obj.userinfo_set.all() [userinfo对象,userinfo对象,]\\2. 小写的表名 得到有外键关系的列 #因为使用values取值取得是字典的不是对象，所以需要 小写表名（外键表）__ v = UserGroup.objects.values(‘id’,’title’)v = UserGroup.objects.values(‘id’,’title’,’小写的表名称’)v = UserGroup.objects.values(‘id’,’title’,’小写的表名称__age’)\\3. 小写的表名 得到有外键关系的列 v = UserGroup.objects.values_list(‘id’,’title’)v = UserGroup.objects.values_list(‘id’,’title’,’小写的表名称’)v = UserGroup.objects.values_list(‘id’,’title’,’小写的表名称__age’) 1对多自关联（ 由原来的2张表，变成一张表！ ） 想象有第二张表，关联自己表中的 行 代码 2、 多对多：1、自己写第3张关系表 ORM多对多查询： 女士表： 男生表： 男女关系表 多对跨表操作 View Code 多对多关系表 数据查找思路 2、第3张关系表不用写(m=models.ManyToManyField(‘ 要关联的表’) 自动生成 ) 由于 DjangoORM中一个类名对应一张表，要想操作表就modles.类直接操作那张表，但**使用ManyToManyField字段生成 “第三张”关系表怎么操作它呢？** 答案：通过单个objd对象 间接操作 View Code 正向操作: obj.m.all() View Code 反向操作 :obj.小写的表名_set 多对多和外键跨表一样都是 小写的表名_set 3、既自定义第三张关系表 也使用ManyToManyField(‘Boy’)字段(杂交类型)ManyToManyField()字段创建第3张关系表，可以使用字段跨表查询，但无法直接操作第3张表， 自建第3表关系表可以直接操作，但无法通过字段 查询，我们可以把他们结合起来使用； 作用： 1、既可以使用字段跨表查询，也可以直接操作第3张关系表 2、obj.m.all() 只有查询和清空 方法 View Code View Code 外键反向查找别名（方便反向查找）在写ForeignKey字段的时候，如果想要在反向查找时不使用默认的 小写的表名_set，就在定义这个字段的时间加related参数！ related_name、related_query_name 字段=什么别名 反向查找时就使用什么别名！ 反向查找： 设置了related_query_name 反向查找时就是obj.别名_set.all（）保留了_set related_query_name View Code related_name反向查找： 设置了relatedname就是 反向查找时就说 obj.别名.all() View Code 操作 View Code 多对多自关联（由原来的3张表，变成只有2张表）把两张表通过 choices字段合并为一张表 ‘第三张关系表’ 使用models.ManyToManyField(‘Userinfo’)生成 特性： obj = models.UserInfo.objects.filter(id=1).first() 获取对象 1、查询第三张关系表前面那一列：obj.m select xx from xx where from_userinfo_id = 1 2、查询第三张关系表后面那一列：obj.userinfo_setselect xx from xx where to_userinfo_id = 1 View Code 查找方法 View Code 多对多自关联特性： ManyToManyField生成的第三张表 五、浅谈ORM查询性能 View Code 六、分组和聚合查询1、aggregate(*args,**kwargs) 聚合函数 通过对QuerySet进行计算，返回一个聚合值的字典。aggregate()中每一个参数都指定一个包含在字典中的返回值。即在查询集上生成聚合。 View Code 2、annotate(*args,**kwargs) 分组函数 View Code 七、F查询与Q查询仅仅靠单一的关键字参数查询已经很难满足查询要求。此时Django为我们提供了F和Q查询： 1、F 可以获取对象中的字段的属性（列），并对其进行操作； 2、Q多条件组合查询 Q（）可以使orm的fifter（）方法支持， 多个查询条件，使用逻辑关系（&amp;、|、~）包含、组合到一起进行多条件查询； 语法： fifter（Q（查询条件1）| Q（查询条件2）） fifter（Q（查询条件2）&amp; Q（查询条件3）） fifter（Q（查询条件4）&amp; ~Q（查询条件5）） fifter（Q（查询条件6）| Q（Q（查询条件4）&amp; ~ Q（Q（查询条件5）&amp; Q（查询条件3）））包含 View Code 注意：Q查询条件和非Q查询条件混合使用注意，不包Q（）的查询条件一点要放在Q（查询条件）后面 八、Django自带ContentType表首先声明本文介绍的ContentType不是http协议中请求头里Content Type，而是Django程序启动后自带的一张表； setings.py配置文件 1、ContentType表内容介绍 ContentType表记录了Django程序的所有APP下model中的表名、和所在app的名称； 2、应用场景： 2.1 通过ContentType中的app名称和表名，查找到Django model中所有表； View Code； 2.2 解决 1张表 同时 其他N张表建立外键，并且多个外键中只能选择1个，关系的复杂问题 场景1：你是一家在线教育的DBA，现有N种优惠券，每1种优惠券怎么分别对应 N门课程中的一1门课程，怎么设计表结构呢？ View Code 场景2 ：学生 学习成绩如何要奖惩、 作业写得如何要奖惩、学习进度如何要奖惩、。。。。。。学生各种行为都要奖惩怎么设计表结构？ View Code 3、content type 操作 model 视图 3.1 GenericForeignKey 创建 给学位课1，创建优惠券100 方式1 方式2 model 视图 3.2 GenericRelation 查询 当前课程都有哪些优惠券？ model 视图 九、补充1.oder_by(-id)：按照某种规则排序 2.exclude(字段)：字段获取数据时排除 View Code 3.按时间查询 Django的orm支持按时间查询数据，前提是你在models中设置了该字段为DateTimeField 以及该字段存储的数据类型为 python的datime时间类型。 提示: 如果在通过时间查询的时候出现 warning 在setings.py中设置如下： 如果时间格式显示英文在setings.py中设置如下： A.查询大于某个时间点产生的数据。（在某个时间点之后） B.大于等于某个时间点 C.小于某个时间点（在某个时间点之前） D.小于等于某个时间点 E.range：查询某个明确时间段数据 (某个时间段） F.__year查询某年产生数据（例如：2018） G.__month查询 某月产生的数据（例：2018年9月） H.__week_day查询某年、某月、星期几产生的数据（例如：2018年9月份 每个星期5） I.查询某年、某月、某天产生的数据 （例：2018年9月10日） "},{"title":"基于阿里云点播","date":"2020-09-28T08:44:34.361Z","url":"/2020/09/28/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E7%82%B9%E6%92%AD/","categories":[["undefined",""]],"content":"阿里云点播视频点播（ApsaraVideo VoD，简称VoD）是集视频采集、编辑、上传、媒体资源管理、自动化转码处理（窄带高清TM）、视频审核分析、分发加速于一体的一站式音视频点播解决方案。"},{"title":"基于时间衰减的热度算法","date":"2020-09-28T02:34:58.315Z","url":"/2020/09/28/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E8%A1%B0%E5%87%8F%E7%9A%84%E7%83%AD%E5%BA%A6%E7%AE%97%E6%B3%95/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"热度算法热门推荐是互联网产品中最常见的功能之一，比如“大家都在看”、“今日热卖榜”这些在各大网站上都随意可见，堪称标配。而其中推荐算法的好坏，则不仅密切关系着内容对用户的吸引程度，也同时反应了产品对内容的分发能力 在一个产品中，如果不能及时发掘新鲜内容，并将优秀内容传播出去，甚至引爆，那么整个内容生态也难以搭建起来。 虽然时下，大家更有兴致讨论的都是个性化推荐，但它并不适用于所有产品，尤其是初创的、小众的产品。因为个性化推荐它必需依赖大量的用户数据以及对内容深入的挖掘，若不然强行个性化推荐只会适得其反。 这次，本文主要探讨实用性更强热度算法，它也并非想象中的简单粗暴，反而有不少只属于它的亮点 基本原理热度算法表层之下，还有不少的基础原理在支撑着它，但在本文中将不先扩展，而是以最普遍运用的牛顿冷却定律为例 牛顿冷却定律若用函数来代表，则为：$$热度 = 初始热度 + 互动热度 – 随时间衰减的热度$$ 当一条微博产生后，随着用户的浏览、点赞、转发、它的热度逐渐攀升，进入榜单。 但因为这条内容本身具有时效性，如果不考虑这点，那么它可能长期霸榜，所以我们必须考虑到如何令它的热度随着时间的推移而衰减，从而令新的微博有机会取而替代，达到热门榜单动态变化的效果 牛顿冷却定律温度高于周围环境的物体向周围媒质传递热量逐渐冷却时所遵循的规律。当物体表面与周围存在温度差时，单位时间从单位面积散失的热量与温度差成正比，比例系数称为热传递系数。牛顿冷却定律是牛顿在1701年用实验确定的，在强制对流时与实际符合较好，在自然对流时只在温度差不太大时才成立。 是传热学的基本定律之一，用于计算对流热量的多少$$\\frac{dN}{dt} = −αN$$ 经过解微方方程可得 $$N(t)=N_0e^{-αt}$$ 热度影响原因初始热度首先是原始热度，正如内容千差万别，再加上产品本身的定位、偏爱。 我们不太可能去为所有的内容赋予同样的初始热度，就比如一个大V发的微博和一个好友发的微博，以及一个陌生小号发的微博，它们从一开始就难以相提并论。 而我们又该如何给每个内容赋予不同的原始热度呢 创作者 即创作这个内容的人，也可以是机构。 还是以微博为例，微博对用户做了不少划分，个人、垂直领域的知名博主、自媒体、机构、企业、政府等等，不同类型的身份也隐含他们的创作能力和传播价值。 所以在初始热度的考量上，我们就会考虑是否让大V用户发表的新内容更先一步的进入热榜。 当然，其它产品就算不像微博那样对用户有明确的归类，也可以利用一些基础的用户数据，比如： 注册时长：是否激励新用户，还是优待老用户？ 活跃程度：一个投入更多时间精力的常驻用户是不是更大概率会创作出优秀内容？ 内容属性 则是从内容本身出发，根据它的类别、字数长度、丰富度、流行指数等有所侧重。 就比如在热门微博管理规范，就表示过含多张的图片，含#话题的就会加重热度，而带外链的，已有相似内容的则会降低热度。 具体哪些内容该赋予更高的热度，哪些内容又该冷处理，关键看这个产品的内容调性和氛关键可能看这个产品中主流用户的偏爱，以及运营人员想营造什么样的内容生态。 热词匹配对于重大事件的报道，如何让它入库时就有更高的热度，可以采用热词匹配的方式 即对大型新闻站点的头条，Twitter热点，竞品的头条做监控和扒取，并将这批新闻的关键词维护到热词库并保持更新；每条新闻入库的时候，让新闻的关键词去匹配热词库，匹配度越高，就有越高的初始热度分 互动热度初始热度这一因素虽然看上去具有极大的天然优势，但往往在实际推荐算法中也不会占据主要的地位。 比如就算是一条超级大V发的和一条普通用户发的内容，可能在初始热度上差距也不会特别大，因为内容是否真的够好，还是要靠更广泛的用户来检验。 这也就是影响热度的第二因素——互动热度，这也是最为重要的，也可以理解为用户的行为数据。 我们需要先定义哪些用户行为可以提高这条内容的热度，像对一条微博的浏览、点赞、评论、转发、分享等，都可以代表了用户对它的感兴趣程度。 同时需要注意的是，不同行为的权重应该也是不同的。 比如，评论明显比点赞更有诚意，所以我们在计算互动热度时，可以对这些用户行为进行评级 浏览+1分，点赞+3分，评论+10分，转发+15分，分享+15分。 且在实际产品运营过程中，我们还需要根据用户规模、周期效应不断调整用户的行为分，同时考虑如何反作弊，若规则太生硬，就会被有心人利用 -随时间衰减的热度由于大部分内容是属于一次消费型，用户看过也就过了。若热门推荐的榜单总是固定那几条，他可能很快就觉得乏味，从而转向别的产品。所以我们自然希望内容能不断更新，而若只看初始热度+互动热度，那么后来者必定很难超越前者。 所以，我们还需要考虑另一个因素——随时间衰减的热度。 以社会热点来说，往往一件事情的时效性是在24小时内。 比如一项政策出台，大家都在关注，若不能及时推送，用户很可能已从别的渠道得知；而新鲜劲一过，这条内容再占着榜单也少有人问津了。 所以我们可以制定一个策略，这个内容在发布后，随着时间的推移，热度也开始逐步衰减。 同时需要注意的是，时间衰减通常不是线性的。 毕竟结合现实情况来看，一条新内容产生后，我们可能先需要几个小时去传播它，看看它的热度反应。 在刚开始这期间，可以不必过多的去考虑时间衰减；而到了有效传播期之后，比如一条新闻过了24小时，那么我们就可以加重时间衰减的因素，尽量不让用户看到昨天的新闻 人工干预在实际的内容运营中，哪怕一套算法再可靠，我们有时候还是难免想要进行一些人工干预 这就涉及到了我们常用的一个手段：调整权重。 我们可以将权重这一因素，扩展到热度算法中，如：$$热度 = 初始热度 + 互动热度 – 随时间衰减的热度 +/- 权重$$然后在运营后台中，开放对内容进行加权、降权的功能。 权重调整其实另一方面也可以弥补热度算法的不足，因为通过传播去获取热度总是需要一定时间，可能没办法应对突发的大热点，而也有某些内容明明在被持续关注着，但却不得不随着时间衰减退出热榜 偶然和极端其实，除了上述我们预先规定好的因素外，还会有一些偶然的元素可能会影响到热度算法。 比如，一条内容在产品往往不止在热榜中可见，我们还会通过其它的方式去传播它 比如开屏、PUSH等，这些都会带来巨量的热度提升，而不是它自身在热榜里竞争所得，若不剔除这些偶然因素，则热榜的前几名很有可能就充满了运营导向的味道。 而且，在设计热度算法时，需要多考虑极端情况，比如若在网站流量不大的情况下 一条初始热度最高的内容，是不是可能永久无法被初始热量最低的内容超越 反作弊在一些知名产品中，热门榜单往往伴随着数据造假，如果我们不能有效的反作弊 那么所谓热榜则相当于名存死亡，成了营销者的聚集之地 将不同用户对互动热度的贡献再次分级前文提到了我们需要对用户的不同行为分级，贡献不同的互动热度；现在考虑到许多刷数据者使用都是批量小号，具有一些区别于正常用户的特征，比如注册时长慢，活跃度低。 那我们就可以对用户进行分群，比如新用户的点赞+0.3分，正常用户的点赞+1分，从而抬高了数据造假的难度和成本 实时监控异常数据，若发现违规，将人工降权因为数据造假是很难模拟出像优秀内容那样的热度上升曲线 所以可以通过监控数据波动，来判断这条内容是否为自然增长，若察觉存在违规现象，则运营可以通过降权进行处罚 抖音视频的推荐算法 首先，抖音有一个流量池的概念，不论新人还是网红，当用户新发一条视频后，抖音都会将它推荐给一定的人，即启动流量，可能是300-1000人 然后根据这条视频在流量池内的数据表现，比如完播率、点赞率、评论数、转发率等，再来决定是否要将这条视频推荐给更多人 而在数据达标之后，抖音会再将这条视频引向更大的流量池，让新的1W-10W人看到，即叠加推荐，以此类推，数据越好，叠加越多的流量 同时，上述所说的流量池是有区间的，决定具体数值，则就是上述影响因素的概念 抖音影响因素 从创作者来看：比如注册信息、粉丝数、历史视频数、以往成绩等 从内容来看：比如视频画质、是否原创、是否独特等 "},{"title":"WebSSH","date":"2020-09-28T02:34:31.907Z","url":"/2020/09/28/webssh/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"WebSSH webssh泛指一种技术可以在网页上实现一个SSH终端。从而无需Xshell之类的模拟终端工具进行SSH连接，将SSH这一比较低层的操作也从C/S架构扭成了B/S架构 这样的架构常用在运维制作开发一些堡垒机等系统中，或是目前比较新型的在线教育方式，通过WebSSH向学生提供一个可以直接使用浏览器进行相关Linux操作或代码编写的学习方式 WebSSh主要是建立客户端与服务端的即时通信 实现方案 此种WebSSH实现方式，将通过结合WebSocket以及后端的Paramiko来进行实现，所需要的技术栈如下 技术介绍 xterm 前端通过xterm插件进行shell黑窗口环境的搭建，这个插件会自动解析由后台paramiko返回的带有标记样式的命令结果，并渲染到浏览器中，非常酷炫 websocket 这里通过websocket进行浏览器与django的数据交通桥梁，Websocket是什么 paramiko paramiko此时的角色用来承担django与Linux环境的交互，将前端发来的命令发送给后台，将后台发来的命令结果返回到前端的xterm组件中 前端实现 前端xterm组件使用：简单 安装xterm vue框架中引入xterm的样式文件 初始化xterm组件并添加两个插件：attach可以将终端附加到websocket流中，fit可以调整终端的大小以及行和列适配父级元素 构建websocket并绑定到终端，websocket地址为ws协议前缀，此时使用的是即将在django中配置Websocket后台视图的路由，这一系列行为将挂载到钩子函数下进行 当浏览器关闭时，也代表着客户端关闭，此时主动断开连接，交给vue的钩子函数来处理这个问题 后端实现 django这里使用dwebsocket模块进行ws的服务端编写与通信 首先确定路由，也是前端的ws连接地址 定义函数，初始化SSH连接对象 由于在SSH通道中，服务端可能返回结果的方式并不是与客户端发起的命令一唱一和，可能是一唱多和，比如类似top这样的命令，一次命令输入之后，服务端会返回N次结果，此时在django视图中采用多线程，专门处理命令结果的返回；以下是这个任务线程函数的定义 剩余的就是视图函数的调用和线程开启部分了！ "},{"title":"Paramiko","date":"2020-09-28T02:34:08.244Z","url":"/2020/09/28/paramiko/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"ParamikoParamiko是SSHv2协议的Python实现，提供客户端和服务器功能 Paramiko本身是一个围绕SSH网络概念的纯Python接口 利用paramiko我们可以通过Python方便的进行ssh操作 paramiko包含两个核心组件：SSHClient和SFTPClient SSHClientSSHClient的作用类似于Linux的ssh命令，是对SSH会话的封装 该类封装了传输Transport，通道Channel及SFTPClient建立的方法open_sftp，通常用于执行远程命令 API class paramiko.client.SSHClient 创建SSH客户端实例 SSHClient.connect(hostname, port=22, username=None, password=None, pkey=None, key_filename=None, timeout=None, allow_agent=True, look_for_keys=True, compress=False..) 通过验证连接远程服务端 SSHClient.exec_command(command, bufsize=-1, timeout=None, get_pty=False, environment=None) command参数为要执行的shell命令，打开一个新通道并执行请求的命令 该函数的返回结果为一个元组，其中包含stdin、stdout和stderr，也就是我们常见的标准输入，输出以及出错 一般来说，命令的结果我们将通过stdout进行获取 SSHClient.close() 关闭SSH连接 SSHClient.invoke_shell(term=’vt100’, width=80, height=24, width_pixels=0, height_pixels=0, environment=None) 在ssh服务器上启动交互式shell会话 一个新的通道被打开并连接到，使用请求的终端类型和大小的伪终端，并作为返回值 换句通俗的话来讲，就是创建了一个实际的shell窗口空间进行命令交互 SSHClient.set_missing_host_key_policy(policy) 设置连接到没有已知主机密钥的服务器时要使用的策略 常见使用策略为paramiko.client.AutoAddPolicy，其意义为自动将主机名和新主机密钥添加到本地主机密钥对象并保存 实例代码 以下是一个简单的通过SSHClient建立的通道进行命令的传输与返回结果的获取的代码！ 上面的代码通过默认建立好的连接对象进行命令的传输以及返回结果的获取 invoke_shell 接下来使用invoke_shell进行虚拟终端的连接，首先初始化SSH通道 思路为开启两个线程，分别负责命令的接收与命令的发送 在实例中定义run函数用来开启两个线程并负责线程的资源回收以及SSH通道的关闭 在win下的CMD中查看效果，其中的乱码格式其实为连接后命令传输的特殊标记格式，可以在后面结合前端中类似xterm.js等插件查看到实际花里胡哨的效果 SFTPClientSFTPClient的作用类似与Linux的sftp命令，是对SFTP客户端的封装 用以实现远程文件操作，如文件上传、下载、修改文件权限等操作 API 官方文档：docs.paramiko.org/en/2.4/api/sftp.html sftp=paramiko.SFTPClient.from_transport(t,window_size=None,max_packet_size=None) 根据参数t指定的已验证传输通道进行SFTP客户端的创建 sftp.put(localpath, remotepath, callback=None, confirm=True) 上传本地路径为localpath的文件到目标主机remotepath处 sftp.get(remotepath, localpath, callback=None) 下载远程路径为remotepath路径的的文件到本地主机localpath处 open(filename, mode=’r’, bufsize=-1) 打开位于远程主机上的文件，与open函数类似，返回文件对象 listdir(path=&#39;.&#39;) 返回给定路径下文件及目录的列表，默认路径为当前工作目录 chdir(path=None) 修改当前SFTP连接会话的工作目录 lstat(path) 检索当前path所指向的文件信息 mkdir(path,mode=511) 根据path在目标主机创建默认权限为511的目录 rmdir(path) 删除给定path所指向的目录 remove(path) 删除给定path所指向的文件 实例代码 以下是一个比较简陋的关于SFTPClient的测试代码 "},{"title":"Mysql搭建主从复制","date":"2020-09-28T02:33:05.936Z","url":"/2020/09/28/Mysql%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","tags":[["mysql","/tags/mysql/"]],"categories":[["mysql","/categories/mysql/"]],"content":"Mysql主从复制 什么是主从复制？ 主从复制至少需要两台服务器，或两个mysql服务，可以配置一主多从，多主多从 建立与某个业务数据库一样的数据库环境，即为主从复制 一般情况下，主库用以写，而从库用以读 为什么要搭建主从复制？ 构建主从热备，当某天数据库宕机或或数据丢失情况，可以有备份数据库继续工作 降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力 隔离读写，在某些锁表情况下，可以使数据库读操作继续进行 主从复制原理 利用数据库bin-log二进制文件，该文件包含有数据库操作的所有SQL语句 复制该文件至其余数据库服务中并执行即可 主从复制过程 当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输binlog日志 从库开启两个线程 A线程：也叫做IO线程，连接主库，并请求binlog中的更新记录至从库中，写入至从库的relaylog文件中 B线程：也叫做SQL线程，读取relaylog文件中的更新操作并执行 如果，有多个从库同时存在，主库会为每个从库建立一个binlog输出线程 环境 此处以一主一丛为例 系统环境 主库（master）：192.168.1.100 从库（slave）：192.168.1.101 主库修改 主库配置修改 server-id： 同步数据中必须包含server-id，用于标识该语句最初是从哪个server写入 每个slave端只能有一个线程在master端连接，如果两个salve端的server-id一致，一个连接成功之后，前一个连接将会被断开 主主同步时，避免数据同步陷入死循环 主库创建用户，用以从机连接获取binlog日志 查看master状态 记录上条命令返回的binlog文件名，Position属性，从机连接的时候要用 从库修改 从库配置修改 master与slave端的server-id不能一样 salve端无需开启log-bin功能 从库指定master，执行如下 启动从机 同步特定的库主机处配置 从机处配置 常见错误 mysql-&gt;mariadb版本问题 从MySQL5.6开始引入了binlog_checksum全局变量，即MySQL会将event的CRC32校验值也写入binlog，显然MariaDB在分析日志的时候不会考虑该信息，导致解析出错 "},{"title":"FastDFS文件存储系统","date":"2020-09-28T02:32:47.419Z","url":"/2020/09/28/fastdfs%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/","tags":[["docker","/tags/docker/"]],"categories":[["docker","/categories/docker/"]],"content":"FastDFS FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务 FastDFS架构包括 Tracker server 和 Storage server。客户端请求Trackerserver进行过文件上传、下载 通过Tracker server调度最终由Storage server完成文件上传、下载 Tracker server 作用是负载均衡和调度,通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为追踪服务器或 调度服务器 Storage server 作用是文件存储,客户端上传的文件最终存储在Storage存储器上,Storageserver没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为存储服务器 centos部署docker 安装docker 开启docker服务 查看docker镜像 REPOSITORY：镜像所在的仓库名称 TAG：镜像标签 IMAGEID：镜像ID CREATED：镜像的创建日期(不是获取该镜像的日期) SIZE：镜像大小 拉取镜像及删除镜像 上面代码中，docker image pull是抓取 image 文件的命令。delron/fastdfs是 image 文件在仓库里面的位置，其中delron是 image 文件所在的组，fastdfs是 image 文件的名字 开启fastdfs的tracker服务 开启fastdfs的storage服务 关闭docker容器 查看当前运行的容器 Fastdfs使用python客户端 下载安装fastdfs的python客户端  windows兼容问题 解压下载好的压缩包，提取fdfs_client文件夹 将该文件夹放入python的三方包目录下 C:\\Python37\\Lib\\site-packages 安装所需的两个额外模块 pip install mutagenpip isntall requests 注释fdfs_client/storage_client.py文件中的第十二行 创建client.conf文件到django下 上传测试代码 其中返回结果中的Remote file_id就是上传成功的保存文件名 Django文件引擎 重构django文件上传引擎 存储类中必须实现_open()和_save()方法,以及任何后续使用中可能用到的其他方法。 _open(name, mode = ‘rb’)：被Storage.open()调用,在打开文件时被调用 save(name, content)：被Storage.save()调用,name是传入的文件名,content是Django接收到的文件内容,该方法需要将content文件内容保存。Django会将该方法的返回值保存到数据库中对应的文件字段,也就是说该方法应该返回要保存在数据库中的文件名信息。 exists(name)：如果名为name的文件在文件系统中存在，按返回True，否则返回False url(name)：返回文件的完整访问URL delete(name)：删除name文件 listdir(path)：列出指定路径的文件 size(name)：返回name文件的总大小 将文件引擎设置到settings中 上传成功后的访问地址 在服务器IP地址的8888端口，记得打开对应阿里云的端口规则 注意：在新版本的Remote file_id，由\\\\斜杠变为了/ "},{"title":"gitlab代码管理工具","date":"2020-09-28T02:31:17.859Z","url":"/2020/09/28/gitlab%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","tags":[["gitlab","/tags/gitlab/"]],"categories":[["gitlab","/categories/gitlab/"]],"content":"gitlab代码管理工具​ GitLab是利用 Ruby on Rails 一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找 git：是一种版本控制系统，是一个命令合集工具 github：是一个基于git实现在线代码托管的仓库，云端代码管理平台，企业版需要付费 gitlab：类似 github，一般用于在企业内部搭建git私服 gitlab-ce：社区版，免费（推荐使用） gitlab-ee：企业版，收费 gitee：即码云，是 oschina 免费给企业用的，云端代码管理平台，企业版需要付费 GitLab让开发团队对他们的代码仓库拥有更多的控制，相对于GitHub，它有不少的特色 允许免费设置仓库权限 允许用户选择分享一个project的部分代码 允许用户设置project的获取权限，进一步提升安全性 可以设置获取到团队整体的改进进度 通过innersourcing让不在权限范围内的人访问不到该资源 下载gitlab-ce免费安装包 安装这个包 修改gitlab配置文件指定服务器ip和自定义端口 生效配置并重启 默认访问密码 "},{"title":"Git笔记","date":"2020-09-28T02:30:43.755Z","url":"/2020/09/28/Git%E7%AC%94%E8%AE%B0/","tags":[["git","/tags/git/"]],"categories":[["git","/categories/git/"]],"content":"Git Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。 Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的临时区域和多个工作流程等功能 git流程 workspace：工作区 Index/Stage：暂存区 Repository：仓库区/本地仓库 Remote：远程仓库 SVN与Git的区别 SVN SVN是集中式版本控制系统，版本库是集中放在中央服务器的、而干活的时候，用的都是自己的电脑 首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器 集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了 Git Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库 这工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了 Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快 用SVN的话，没有网络或者断开VPN你就无法做任何事情 但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程的镜像仓库。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦 安装git Windows： Linux： Git配置 git config --global：全局git配置，这台机器所有的Git仓库均会使用这个配置 git操作创建版本库 什么是版本库？ 版本库又名仓库，英文名repository 你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件还原 选择，进入某个目录 初始化目录为本地仓库 初始化之后，目录下会多一个隐藏目录.git，该目录是git用来管理版本的， 添加项目文件 以创建django项目为例，在git本地仓库开启一个django项目 添加项目文件或目录至暂存区 将暂存区内容提交至本地仓库 -m参数指定提交注释 查看此时仓库状态 文件修改提交 如果在开发过程中，对其中的某个文件进行了修改，那么git在对比文件指纹的过程中发现了差异，此时也需要将新修改的文件进行提交 修改settings.py文件配置 查看仓库状态 此时仓库说，modified: settings.py，我们对其中某个文件进行了修改 将修改之后的文件加入暂存区 此时查看状态 将暂存区的内容提交至本地仓库 丢弃修改，可以丢弃工作区对于文件的修改 注意：命令git checkout -- settings.py中的--很重要，如果没有--的话，那么命令变成创建分支了 文件删除提交 在django项目的隔壁创建一个1.py文件 添加该文件 删除该文件 恢复删除文件 提交至本地工作区 git commit -a：提交全部修改 git远程仓库 在团队开发中，我们需要每个开发者彼此配合，对同一款项目代码进行编写，此时需要我们借助线上仓库 github： gitee： 由于网络环境，此处选择gitee 将远程仓库添加到本地 添加一个远程库，库名为edu，地址是git@gitee.com:eastside/edu.git 列举当前所有的远程库 删除某个远程库 将本地的仓库推到名为edu的远程仓库中 将远程仓库的代码拉取到本地，在第一次拉取时，可能因为缺少远程服务器上的README.txt文件，而导致远程和本地的分支不一样，通过以下命令 将远程仓库克隆到本地 这是一个已经和远程仓库master分支关联的本地仓库 git全局配置多个用户名冲突时 GIT分支 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支 截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支 我们可以通过checkout命令进行分支的创建及切换 git checkout -b：创建并切换分支 git branch branchname：创建分支 git checkout branchname：切换分支 创建一个测试分支 删除一个分支 提交分支代码 合并分支 GIT冲突 常见git冲突造成，是由于在多个分支下，或多个仓库中，对同一个文件修改，或添加了新的文件之后 由于某一方对于文件的修改没有及时在另一方生效，当另一方或另一分支在进行提交时，即会出现冲突 在testbranch分支下，修改1.py文件，并提交到云仓库 在master分支下，也修改1.py文件，并尝试提交 此时冲突出现，使用git status命令查看当前仓库状态 查看被修改的文件1.py Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt; testbranch是指fenzhi1上修改的内容，我们可以将差异部分的标注删掉重新提交，或是与对方协商，另行拷贝文件内容，重新clone仓库，将拷贝过的内容添加至内 之后再进行提交 这样就可以搞定了 原则：谁冲突谁解决，协商解决 方案：保留所有代码，或保留一人代码 之后add、commit、push 避免冲突 先pull再修改，修改完立即commit和push 确保自己修改的共有文件是最新的 模块化开发，各自管理各自内容 待修改文件同时只有单人修改 下班提交，上班拉取 不擅自篡改代码 "},{"title":"md 用法及其一些常用的语法","date":"2020-09-27T10:28:49.713Z","url":"/2020/09/27/%E8%BF%99%E6%98%AF%E7%AC%AC%E4%B8%80%E7%AF%87/","categories":[["undefined",""]],"content":"这是第一篇。一个新的开始 "},{"title":"Hello World","date":"2020-09-25T07:28:13.919Z","url":"/2020/09/25/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"},{"title":"HTTP、WSGI、TCP","date":"2020-08-26T08:21:31.070Z","url":"/2020/08/26/HTTP%E3%80%81WSGI%E3%80%81TCP/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"[TOC] 一、HTTP的十个问题 二、WSGI的五个问题 三、TCP的五个问题"},{"title":"支付宝三方支付","date":"2020-08-18T01:51:22.730Z","url":"/2020/08/18/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":" 支付宝支付 "},{"title":"Docker 拉取Nginx镜像 和运行","date":"2020-08-13T09:07:23.247Z","url":"/2020/08/13/Docker%20%E6%8B%89%E5%8F%96Nginx%E9%95%9C%E5%83%8F%20%E5%92%8C%E8%BF%90%E8%A1%8C/","tags":[["docker","/tags/docker/"]],"categories":[["docker","/categories/docker/"]],"content":"Docker 拉取Nginx镜像 和运行（三）Docker 镜像拉取 docker pull [OPTIONS] NAME[:TAG|@DIGEST] 镜像拉取命令 docker images 查询所有镜像 docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 运行镜像docker run –help 可查看 OPTIONS 参数 Docker 运行 Nginx 镜像 Nginx 持久运行 Nginx 前台 &amp; 后台 运行 进入容器内部 查看、 镜像仓库 查找 Nginx 镜像  运行docker：systemctl start docker docker pull hub.c.163.com/library/nginx:latest 下载镜像docker images 查询下载的镜像docker run -d hub.c.163.com/library/nginx 运行 Nginx镜像 -d 后台启动docker ps 查看docker 运行的镜像docker exec -it 2189917c05ac bash 查看镜像内部docker stop 镜像id 关闭镜像docker run -d -p 8080:80 hub.c.163.com/library/nginx -d 后台运行 -p 映射端口 8080 映射端口 80 nginx端口-p 映射 指定端口 -P 映射全部端口（p大小写 ）浏览器访问 8080 端口 现在 镜像启动成功 "},{"title":"shell编程四剑客","date":"2020-08-08T08:07:29.573Z","url":"/2020/08/08/shell%E7%BC%96%E7%A8%8B%E5%9B%9B%E5%89%91%E5%AE%A2/","tags":[["shell","/tags/shell/"]],"categories":[["shell","/categories/shell/"]],"content":"shell编程四剑客之sed shell编程四剑客分别的作用 sed 命令 参数及命令 元字符集 "},{"title":"shell编程四剑客之awk","date":"2020-08-08T08:07:16.208Z","url":"/2020/08/08/shell%E7%BC%96%E7%A8%8B%E5%9B%9B%E5%89%91%E5%AE%A2%E4%B9%8BAWK/","tags":[["shell","/tags/shell/"]],"categories":[["shell","/categories/shell/"]],"content":"[TOC] shell编程四剑客之awkawk是一个优良的文本处理工具，Linux及UNIX环境中现有的功能最强大的数据处理引擎之一，以Aho、Weinberger、Kernighan三位发明者名字首字母命名为awk，awk是一个行级文本高效处理工具，awk经过改进生成的新的版本有nawk、gawk，一般Linux默认为gawk，gawk是awk的GNU开源免费版本。awk基本原理是逐行处理文件中的数据，查找与命令行中所给定内容相匹配的模式，如果发现匹配内容，则进行下一个编程步骤，如果找不到匹配内容，则继续处理下一行 awk语言的最基本功能是在文件或字符串中基于指定规则来分解抽取信息,也可以基于指定的规则来输出数据。完整的awk脚本通常用来格式化文本文件中的信息 awk基本用法首先请记住：awk以文件的一行为处理单位。在使用过程中，awk每接收一行，然后执行相应的命令，来处理这一行的文本。不管你看到的一个awk命令多么复杂，多么高端，它总能归结于下述的这行命令模版。 awk ‘pattern {action}’ filenames awk常用参数、变量、函数详解如下。 "},{"title":"SHELL编程四剑客之Grep","date":"2020-08-08T08:07:11.339Z","url":"/2020/08/08/Shell%E7%BC%96%E7%A8%8B%E5%9B%9B%E5%89%91%E5%AE%A2%E4%B9%8BGREP/","tags":[["shell","/tags/shell/"]],"categories":[["shell","/categories/shell/"]],"content":"1.SHELL编程四剑客之Grep工具 2.Grep使用格式： 3.Grep常用参数详解如下： 4.通配符类型详解： 5.正则表达式详解： 6.grep实战演练： 7.易误点："},{"title":"单点登录","date":"2020-08-08T03:26:07.138Z","url":"/2020/08/08/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88%E4%B9%9F%E5%8F%ABSSO%EF%BC%89/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"单点登录（也叫SSO）1.介绍，什么是单点登录 SSO英文全称Single SignOn，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。 2.实现机制 3.为什么要使用SSO（它的好处） 3.1方便用户 3.2方便管理员 3.3简化应用系统开发 4.SSO实现方案常见的跨域登录问题 1.对于同一个根域下的登录问题 2.对于多个根域下的登录问题 方法一：登录成功后将Cookie回写到多个域名下 方法二：jsonp 方法三：引入一个中间态的Server 如下图所示： 方法四：基于CAS的OSS系统 盗图一张说明sso单个域的登录和验证流程： 接下来看下站点2的登录： 注：运营系统也是采用这种方式处理的 基于当前现状，单点登录系统可以有一下处理 5.Spring Security 介绍 6.OAUTH2(类似于中间商) 7.授权模式讲解（有多种不同的授权方式） 授权码模式 下面是上面这些步骤所需要的参数。A步骤中，客户端申请认证的URI，包含以下参数： –response_type：表示授权类型，必选项，此处的值固定为”code”–client_id：表示客户端的ID，必选项–redirect_uri：表示重定向URI，可选项–scope：表示申请的权限范围，可选项–state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值 C步骤中，服务器回应客户端的URI，包含以下参数： –code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。 –state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数： –grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。 –code：表示上一步获得的授权码，必选项。 –redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。 –client_id：表示客户端ID，必选项。 E步骤中，认证服务器发送的HTTP回复，包含以下参数： –access_token：表示访问令牌，必选项。 –token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。 –expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 –refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。 –scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 简化模式 简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 密码模式密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。 在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。 它的步骤如下： （A）用户向客户端提供用户名和密码。 （B）客户端将用户名和密码发给认证服务器，向后者请求令牌。 （C）认证服务器确认无误后，向客户端提供访问令牌。 B步骤中，客户端发出的HTTP请求，包含以下参数： -grant_type：表示授权类型，此处的值固定为”password”，必选项。 -username：表示用户名，必选项。 -password：表示用户的密码，必选项。 -scope：表示权限范围，可选项。 C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。 客户端模式 客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。 它的步骤如下： （A）客户端向认证服务器进行身份认证，并要求一个访问令牌。 （B）认证服务器确认无误后，向客户端提供访问令牌。 A步骤中，客户端发出的HTTP请求，包含以下参数： -granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。 -scope：表示权限范围，可选项。 B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。 "},{"title":"CKEditor","date":"2020-08-04T02:35:58.185Z","url":"/2020/08/04/CKEditor/","tags":[["django","/tags/django/"]],"categories":[["django","/categories/django/"]],"content":"CKEditor注意：django==2.2 版本会报错 安装CKEditor 组件引入CKEditor 模版标签嵌入 vue实例数据保存编辑器实例 钩子函数初始化CKEditor编辑器 在django中响应图片上传的接口 整个页面的提交，需要在vue组件template中绑定按钮点击时间 post_editor的提交事件方法 后端接收整个富文本部分的内容 "}]